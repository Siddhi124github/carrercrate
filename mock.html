<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CareerCrate - Dual Mode Interview</title>
    <style>
        /* ... (keep all your existing CSS styles exactly as they are) ... */

        /* Add these new styles for better feedback formatting */
        .feedback-section {
            margin-bottom: 2rem;
        }

        .feedback-section h4 {
            color: var(--primary);
            margin-bottom: 1rem;
            font-size: 1.2rem;
            border-bottom: 2px solid var(--primary);
            padding-bottom: 0.5rem;
        }

        .feedback-point {
            background: var(--light);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            border-left: 4px solid var(--primary);
        }

        .feedback-point.positive {
            border-left-color: var(--success);
        }

        .feedback-point.negative {
            border-left-color: var(--accent);
        }

        .feedback-point.suggestion {
            border-left-color: var(--warning);
        }

        .score-display {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin: 1rem 0;
            padding: 1rem;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            border-radius: 10px;
        }

        .score-value {
            font-size: 2rem;
            font-weight: bold;
        }

        .score-label {
            font-size: 1rem;
            opacity: 0.9;
        }

        /* Mobile-specific voice fixes */
        @media (max-width: 768px) {
            .voice-controls {
                gap: 1rem;
            }
            
            .voice-btn {
                padding: 1.2rem 1.5rem;
                font-size: 1.1rem;
            }
            
            .transcript-display {
                min-height: 80px;
                max-height: 120px;
                font-size: 1rem;
            }
            
            .control-buttons {
                gap: 0.75rem;
            }
            
            .control-buttons .btn {
                padding: 1rem;
                font-size: 1rem;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- ... (keep all your existing HTML structure exactly as it is) ... -->

    <script>
        // Fix for mobile voice recording
        const API_BASE_URL = window.location.origin.includes('5500') 
            ? 'http://localhost:3001' 
            : window.location.origin;
        
        const interviewState = {
            sessionId: null,
            questionCount: 0,
            maxQuestions: 10,
            currentStage: 'basic',
            stages: ['basic', 'role', 'technical', 'resume', 'behavioral', 'salary'],
            interviewMode: 'text',
            isRecording: false,
            recognition: null,
            currentTranscript: '',
            currentAudio: null,
            isSpeaking: false,
            mediaStream: null,
            audioContext: null,
            analyser: null
        };

        // DOM elements
        const setupScreen = document.getElementById('setupScreen');
        const interviewScreen = document.getElementById('interviewScreen');
        const feedbackScreen = document.getElementById('feedbackScreen');
        const jobRoleInput = document.getElementById('jobRole');
        const resumeTextArea = document.getElementById('resumeText');
        const chatContainer = document.getElementById('chatContainer');
        const userAnswer = document.getElementById('userAnswer');
        const submitBtn = document.getElementById('submitBtn');
        const typingIndicator = document.getElementById('typingIndicator');
        const feedbackContent = document.getElementById('feedbackContent');
        const stageIndicator = document.getElementById('stageIndicator');
        const progressText = document.getElementById('progressText');
        const progressFill = document.getElementById('progressFill');
        const setupError = document.getElementById('setupError');
        const interviewError = document.getElementById('interviewError');
        const feedbackJobRole = document.getElementById('feedbackJobRole');
        const feedbackQuestionCount = document.getElementById('feedbackQuestionCount');
        const interviewDate = document.getElementById('interviewDate');
        const interviewMode = document.getElementById('interviewMode');
        const interviewerAvatar = document.getElementById('interviewerAvatar');
        const avatarSection = document.getElementById('avatarSection');
        const interviewInfo = document.getElementById('interviewInfo');
        const feedbackActions = document.getElementById('feedbackActions');
        
        // Voice elements
        const voiceControls = document.getElementById('voiceControls');
        const textControls = document.getElementById('textControls');
        const recordBtn = document.getElementById('recordBtn');
        const submitVoiceBtn = document.getElementById('submitVoiceBtn');
        const voiceStatus = document.getElementById('voiceStatus');
        const transcriptDisplay = document.getElementById('transcriptDisplay');
        const voiceVisualizer = document.getElementById('voiceVisualizer');

        // Mobile menu elements
        const menuToggle = document.getElementById('menuToggle');
        const mobileMenu = document.getElementById('mobileMenu');

        const stageLabels = {
            'basic': 'Professional Background',
            'role': 'Role-specific Questions', 
            'technical': 'Technical Assessment',
            'resume': 'Experience Review',
            'behavioral': 'Behavioral Analysis',
            'salary': 'Compensation Discussion'
        };

        // Mobile menu toggle
        if (menuToggle && mobileMenu) {
            menuToggle.addEventListener('click', function() {
                mobileMenu.classList.toggle('open');
                // Toggle menu icon
                const icon = menuToggle.querySelector('i');
                if (mobileMenu.classList.contains('open')) {
                    icon.classList.remove('fa-bars');
                    icon.classList.add('fa-times');
                } else {
                    icon.classList.remove('fa-times');
                    icon.classList.add('fa-bars');
                }
            });

            // Close mobile menu when clicking on a link
            document.querySelectorAll('.mobile-menu a').forEach(link => {
                link.addEventListener('click', function() {
                    mobileMenu.classList.remove('open');
                    const icon = menuToggle.querySelector('i');
                    icon.classList.remove('fa-times');
                    icon.classList.add('fa-bars');
                });
            });
        }

        // Initialize audio visualizer bars
        function initVisualizer() {
            voiceVisualizer.innerHTML = '';
            for (let i = 0; i < 40; i++) {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = '2px';
                voiceVisualizer.appendChild(bar);
            }
        }

        // Update visualizer based on audio level
        function updateVisualizer(level) {
            const bars = voiceVisualizer.getElementsByClassName('bar');
            const activeBars = Math.floor((level / 100) * bars.length);
            
            for (let i = 0; i < bars.length; i++) {
                if (i < activeBars) {
                    const height = 2 + (i * 2);
                    bars[i].style.height = `${height}px`;
                    bars[i].style.background = `hsl(${210 + (i * 2)}, 100%, 50%)`;
                } else {
                    bars[i].style.height = '2px';
                    bars[i].style.background = 'var(--primary)';
                }
            }
        }

        // Set interview mode (voice or text)
        function setInterviewMode(mode) {
            interviewState.interviewMode = mode;
            
            // Update mode buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update display
            if (mode === 'voice') {
                voiceControls.style.display = 'flex';
                textControls.style.display = 'none';
                avatarSection.style.display = 'flex';
                interviewInfo.style.display = 'block';
                initVisualizer();
                
                // Initialize speech recognition for mobile
                if (isMobileDevice()) {
                    initializeMobileSpeechRecognition();
                }
            } else {
                voiceControls.style.display = 'none';
                textControls.style.display = 'block';
                avatarSection.style.display = 'none';
                interviewInfo.style.display = 'none';
            }
        }

        // Check if device is mobile
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // Initialize mobile speech recognition
        function initializeMobileSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.warn('Speech recognition not supported');
                return;
            }
            
            // Pre-initialize recognition for faster startup
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            interviewState.recognition = new SpeechRecognition();
            interviewState.recognition.continuous = true;
            interviewState.recognition.interimResults = true;
            interviewState.recognition.lang = 'en-US';
            
            setupRecognitionEvents();
        }

        // Setup recognition events
        function setupRecognitionEvents() {
            if (!interviewState.recognition) return;
            
            interviewState.recognition.onstart = function() {
                console.log('Speech recognition started');
                interviewState.isRecording = true;
                recordBtn.classList.add('recording');
                recordBtn.innerHTML = '<span>üî¥</span> Stop Recording';
                voiceStatus.textContent = 'Listening... Speak now';
                submitVoiceBtn.disabled = true;
            };

            interviewState.recognition.onresult = function(event) {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                interviewState.currentTranscript = finalTranscript || interimTranscript;
                transcriptDisplay.textContent = interviewState.currentTranscript;
                
                // Enable submit button when we have content
                if (interviewState.currentTranscript.trim().length > 10) {
                    submitVoiceBtn.disabled = false;
                }
            };

            interviewState.recognition.onerror = function(event) {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'not-allowed') {
                    showError(interviewError, 'Microphone access denied. Please allow microphone permissions in your browser settings.');
                } else if (event.error === 'audio-capture') {
                    showError(interviewError, 'No microphone found. Please check your audio device.');
                }
                stopRecording();
            };

            interviewState.recognition.onend = function() {
                console.log('Speech recognition ended');
                if (interviewState.isRecording) {
                    // Auto-restart if still recording (for mobile compatibility)
                    setTimeout(() => {
                        if (interviewState.isRecording && interviewState.recognition) {
                            try {
                                interviewState.recognition.start();
                            } catch (e) {
                                console.log('Restarting recognition failed:', e);
                            }
                        }
                    }, 100);
                }
            };
        }

        // Text-to-Speech function
        function speakText(text) {
            if (interviewState.interviewMode !== 'voice') return;
            
            // Stop any currently playing audio
            if (interviewState.currentAudio) {
                speechSynthesis.cancel();
                interviewState.isSpeaking = false;
                interviewerAvatar.classList.remove('speaking');
            }
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.9;
            utterance.pitch = 1;
            utterance.volume = 1;
            
            // Set voice if available
            const voices = speechSynthesis.getVoices();
            const preferredVoice = voices.find(voice => 
                voice.name.includes('Google') || 
                voice.name.includes('Microsoft') || 
                voice.name.includes('Samantha') ||
                voice.name.includes('Karen') ||
                voice.name.includes('Daniel')
            );
            
            if (preferredVoice) {
                utterance.voice = preferredVoice;
            }
            
            utterance.onstart = function() {
                interviewState.isSpeaking = true;
                interviewerAvatar.classList.add('speaking');
            };
            
            utterance.onend = function() {
                interviewState.isSpeaking = false;
                interviewerAvatar.classList.remove('speaking');
            };
            
            utterance.onerror = function(event) {
                console.error('Speech synthesis error:', event);
                interviewState.isSpeaking = false;
                interviewerAvatar.classList.remove('speaking');
            };
            
            interviewState.currentAudio = utterance;
            speechSynthesis.speak(utterance);
        }

        // Toggle recording - FIXED FOR MOBILE
        async function toggleRecording() {
            if (!interviewState.isRecording) {
                try {
                    // Request microphone permission with better error handling
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 44100
                        } 
                    }).catch(error => {
                        console.error('Microphone access error:', error);
                        showError(interviewError, 'Cannot access microphone. Please check permissions and try again.');
                        throw error;
                    });
                    
                    interviewState.mediaStream = stream;
                    
                    // Setup audio context for visualization
                    try {
                        interviewState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const source = interviewState.audioContext.createMediaStreamSource(stream);
                        interviewState.analyser = interviewState.audioContext.createAnalyser();
                        source.connect(interviewState.analyser);
                        
                        // Start visualizer animation
                        const bufferLength = interviewState.analyser.frequencyBinCount;
                        const dataArray = new Uint8Array(bufferLength);
                        
                        function updateMeter() {
                            if (!interviewState.isRecording) return;
                            
                            interviewState.analyser.getByteFrequencyData(dataArray);
                            let sum = 0;
                            for (let i = 0; i < bufferLength; i++) {
                                sum += dataArray[i];
                            }
                            const average = sum / bufferLength;
                            updateVisualizer(average);
                            requestAnimationFrame(updateMeter);
                        }
                        updateMeter();
                    } catch (audioError) {
                        console.warn('Audio visualization failed:', audioError);
                    }
                    
                    // Setup speech recognition if not already done
                    if (!interviewState.recognition) {
                        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                            showError(interviewError, 'Speech recognition not supported in this browser.');
                            return;
                        }
                        
                        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                        interviewState.recognition = new SpeechRecognition();
                        interviewState.recognition.continuous = true;
                        interviewState.recognition.interimResults = true;
                        interviewState.recognition.lang = 'en-US';
                        
                        setupRecognitionEvents();
                    }
                    
                    // Start recognition
                    try {
                        interviewState.recognition.start();
                    } catch (startError) {
                        console.error('Failed to start recognition:', startError);
                        showError(interviewError, 'Failed to start voice recording. Please try again.');
                        stopRecording();
                    }
                    
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    if (error.name === 'NotAllowedError') {
                        showError(interviewError, 'Microphone permission denied. Please allow microphone access in your browser settings.');
                    } else if (error.name === 'NotFoundError') {
                        showError(interviewError, 'No microphone found. Please check your audio device.');
                    } else {
                        showError(interviewError, 'Cannot access microphone. Please check permissions and try again.');
                    }
                }
            } else {
                stopRecording();
            }
        }

        function stopRecording() {
            if (interviewState.recognition) {
                try {
                    interviewState.recognition.stop();
                interviewState.recognition = null;
                console.log('Speech recognition stopped');
                interviewState.isRecording = false;
                recordBtn.classList.remove('recording');
                recordBtn.innerHTML = '<span>üé§</span> Start Recording';
                voiceStatus.textContent = 'Recording stopped. Review your transcript above.';
                
                // Reset visualizer
                initVisualizer();
            } catch (error) {
                console.error('Error stopping recognition:', error);
            }
            
            if (interviewState.mediaStream) {
                interviewState.mediaStream.getTracks().forEach(track => track.stop());
                interviewState.mediaStream = null;
            }
            
            if (interviewState.audioContext) {
                interviewState.audioContext.close().catch(console.error);
                interviewState.audioContext = null;
            }
        }

        // Submit voice answer - FIXED FOR MOBILE
        async function submitVoiceAnswer() {
            if (!interviewState.currentTranscript.trim()) {
                showError(interviewError, 'Please record your answer first');
                return;
            }

            // Show loading state
            submitVoiceBtn.disabled = true;
            submitVoiceBtn.textContent = 'Submitting...';
            
            try {
                await submitAnswer(interviewState.currentTranscript);
                interviewState.currentTranscript = '';
                transcriptDisplay.textContent = 'Your speech will appear here...';
            } catch (error) {
                console.error('Error submitting voice answer:', error);
                showError(interviewError, 'Error submitting response. Please try again.');
            } finally {
                submitVoiceBtn.disabled = false;
                submitVoiceBtn.textContent = 'Submit Response';
            }
        }

        // Modified submitAnswer to handle both text and voice
        async function submitAnswer(answerText = null) {
            const answer = answerText || userAnswer.value.trim();
            
            if (!answer) {
                showError(interviewError, 'Please provide your response');
                return;
            }

            if (!interviewState.sessionId) {
                showError(interviewError, 'No active interview session');
                return;
            }

            addMessage(answer, 'user');
            if (!answerText) userAnswer.value = '';
            submitBtn.disabled = true;
            submitVoiceBtn.disabled = true;
            showTyping(true);

            try {
                const response = await fetch(`${API_BASE_URL}/interview/answer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        sessionId: interviewState.sessionId, 
                        answer: answer 
                    })
                });

                if (!response.ok) throw new Error('Failed to submit answer');

                const data = await response.json();

                if (data.feedback) {
                    showFeedback(data.feedback);
                    return;
                }

                if (data.question) {
                    addMessage(data.question, 'ai');
                    interviewState.questionCount = data.questionCount;
                    updateProgress();
                    updateStageIndicator(data.stage);
                    
                    // Speak the question automatically if in voice mode
                    if (interviewState.interviewMode === 'voice') {
                        speakText(data.question);
                    }
                }

            } catch (error) {
                showError(interviewError, 'Error submitting response');
            } finally {
                submitBtn.disabled = false;
                submitVoiceBtn.disabled = false;
                showTyping(false);
                if (interviewState.interviewMode === 'text') {
                    userAnswer.focus();
                }
            }
        }

        // IMPROVED FEEDBACK FORMATTING
        function showFeedback(feedback) {
            showScreen('feedback');

            feedbackJobRole.textContent = jobRoleInput.value || 'Not specified';
            feedbackQuestionCount.textContent = interviewState.questionCount;
            interviewDate.textContent = new Date().toLocaleDateString();
            interviewMode.textContent = interviewState.interviewMode === 'voice' ? 'Voice' : 'Text';
            
            let formattedFeedback = '';
            
            if (typeof feedback === 'string') {
                // Parse and format the feedback string
                formattedFeedback = formatFeedbackString(feedback);
            } else if (typeof feedback === 'object') {
                // Format object feedback
                formattedFeedback = formatFeedbackObject(feedback);
            } else {
                formattedFeedback = `
                    <div class="feedback-item">
                        <div style="text-align: center; padding: 2rem; color: var(--gray);">
                            <i class="fas fa-info-circle" style="font-size: 3rem; margin-bottom: 1rem;"></i>
                            <p>No detailed feedback available for this session.</p>
                        </div>
                    </div>
                `;
            }
            
            feedbackContent.innerHTML = formattedFeedback;
            
            // Only show "Practice Again" button in voice mode
            if (interviewState.interviewMode === 'voice') {
                const practiceAgainBtn = document.createElement('button');
                practiceAgainBtn.className = 'btn';
                practiceAgainBtn.textContent = 'üé§ Practice Again';
                practiceAgainBtn.onclick = restartInterview;
                feedbackActions.insertBefore(practiceAgainBtn, feedbackActions.firstChild);
            }
        }

        // Format feedback string into structured sections
        function formatFeedbackString(feedback) {
            const sections = feedback.split(/\n\n|\n\s*\n/);
            let html = '';
            
            // Try to detect score first
            const scoreMatch = feedback.match(/(\d+(?:\.\d+)?)\/10|(\d+(?:\.\d+)?)%|score.*?(\d+(?:\.\d+)?)/i);
            if (scoreMatch) {
                const score = scoreMatch[1] || scoreMatch[2] || scoreMatch[3];
                html += `
                    <div class="score-display">
                        <div class="score-value">${score}</div>
                        <div class="score-label">Overall Performance Score</div>
                    </div>
                `;
            }
            
            sections.forEach(section => {
                const lines = section.split('\n').filter(line => line.trim());
                if (lines.length === 0) return;
                
                const title = lines[0].trim();
                const content = lines.slice(1).join('<br>');
                
                // Detect section type
                let sectionType = 'general';
                if (title.toLowerCase().includes('strength') || title.toLowerCase().includes('positive')) {
                    sectionType = 'positive';
                } else if (title.toLowerCase().includes('improve') || title.toLowerCase().includes('weakness') || title.toLowerCase().includes('negative')) {
                    sectionType = 'negative';
                } else if (title.toLowerCase().includes('suggestion') || title.toLowerCase().includes('recommend')) {
                    sectionType = 'suggestion';
                }
                
                if (lines.length > 1) {
                    // Section with title and content
                    html += `
                        <div class="feedback-section">
                            <h4>${title}</h4>
                            <div class="feedback-point ${sectionType}">
                                ${content || 'No specific feedback provided.'}
                            </div>
                        </div>
                    `;
                } else {
                    // Single paragraph
                    html += `
                        <div class="feedback-section">
                            <div class="feedback-point general">
                                ${title}
                            </div>
                        </div>
                    `;
                }
            });
            
            return html || `
                <div class="feedback-item">
                    <div style="white-space: pre-line; line-height: 1.6;">${feedback}</div>
                </div>
            `;
        }

        // Format feedback object
        function formatFeedbackObject(feedback) {
            let html = '';
            
            // Overall score
            if (feedback.score || feedback.rating) {
                const score = feedback.score || feedback.rating;
                html += `
                    <div class="score-display">
                        <div class="score-value">${score}</div>
                        <div class="score-label">Overall Performance Score</div>
                    </div>
                `;
            }
            
            // Strengths
            if (feedback.strengths && feedback.strengths.length > 0) {
                html += `
                    <div class="feedback-section">
                        <h4>‚úÖ Strengths</h4>
                        ${feedback.strengths.map(strength => `
                            <div class="feedback-point positive">
                                ${strength}
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            // Areas for improvement
            if (feedback.improvements && feedback.improvements.length > 0) {
                html += `
                    <div class="feedback-section">
                        <h4>üìà Areas for Improvement</h4>
                        ${feedback.improvements.map(improvement => `
                            <div class="feedback-point negative">
                                ${improvement}
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            // Suggestions
            if (feedback.suggestions && feedback.suggestions.length > 0) {
                html += `
                    <div class="feedback-section">
                        <h4>üí° Recommendations</h4>
                        ${feedback.suggestions.map(suggestion => `
                            <div class="feedback-point suggestion">
                                ${suggestion}
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            // General feedback
            if (feedback.summary || feedback.general) {
                html += `
                    <div class="feedback-section">
                        <h4>üìù Overall Assessment</h4>
                        <div class="feedback-point general">
                            ${feedback.summary || feedback.general}
                        </div>
                    </div>
                `;
            }
            
            return html || `
                <div class="feedback-item">
                    <div style="white-space: pre-line; line-height: 1.6;">${JSON.stringify(feedback, null, 2)}</div>
                </div>
            `;
        }

        // Rest of your existing functions remain the same...
        function showScreen(screen) {
            setupScreen.style.display = 'none';
            interviewScreen.style.display = 'none';
            feedbackScreen.style.display = 'none';
            
            if (screen === 'setup') setupScreen.style.display = 'block';
            else if (screen === 'interview') interviewScreen.style.display = 'block';
            else if (screen === 'feedback') feedbackScreen.style.display = 'block';
        }

        function showError(element, message) {
            element.textContent = message;
            element.style.display = 'block';
            setTimeout(() => element.style.display = 'none', 5000);
        }

        function showTyping(show) {
            typingIndicator.style.display = show ? 'block' : 'none';
        }

        function addMessage(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            
            let messageHeader = `<div class="message-header">${sender === 'ai' ? 'Interviewer' : 'You'}</div>`;
            
            if (sender === 'ai' && interviewState.interviewMode === 'voice') {
                const escapedText = text.replace(/'/g, "\\'");
                messageHeader = `
                    <div class="message-header">
                        <span>Interviewer</span>
                        <button class="audio-btn" onclick="speakText('${escapedText}')">üîä</button>
                    </div>
                `;
            }
            
            messageDiv.innerHTML = `
                ${messageHeader}
                <div>${text}</div>
            `;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function updateProgress() {
            const progress = (interviewState.questionCount / interviewState.maxQuestions) * 100;
            progressText.textContent = `Question ${interviewState.questionCount} of ${interviewState.maxQuestions}`;
            progressFill.style.width = `${progress}%`;
        }

        function updateStageIndicator(stage) {
            stageIndicator.textContent = stageLabels[stage] || stage;
            interviewState.currentStage = stage;
        }

        async function startInterview() {
            const jobRole = jobRoleInput.value.trim();
            const resumeText = resumeTextArea.value.trim();
            
            if (!jobRole) {
                showError(setupError, 'Please specify the target position');
                return;
            }
            
            if (!resumeText) {
                showError(setupError, 'Please provide your professional background');
                return;
            }

            try {
                submitBtn.disabled = true;
                submitVoiceBtn.disabled = true;
                showTyping(true);

                const response = await fetch(`${API_BASE_URL}/interview/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ jobRole, resumeText })
                });

                if (!response.ok) throw new Error('Failed to start interview');

                const data = await response.json();
                
                interviewState.sessionId = data.sessionId;
                interviewState.questionCount = data.questionCount;
                interviewState.maxQuestions = data.maxQuestions;

                chatContainer.innerHTML = '';
                addMessage(data.question, 'ai');
                
                updateProgress();
                updateStageIndicator(data.stage);
                showScreen('interview');

                if (interviewState.interviewMode === 'voice') {
                    initVisualizer();
                    speakText(data.question);
                }

            } catch (error) {
                showError(setupError, 'Error starting interview');
            } finally {
                submitBtn.disabled = false;
                submitVoiceBtn.disabled = false;
                showTyping(false);
                if (interviewState.interviewMode === 'text') {
                    userAnswer.focus();
                }
            }
        }

        async function askForClarification() {
            if (!interviewState.sessionId) return;

            addMessage("Could you please clarify or rephrase the question?", 'user');
            submitBtn.disabled = true;
            submitVoiceBtn.disabled = true;
            showTyping(true);

            try {
                const response = await fetch(`${API_BASE_URL}/interview/clarify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: interviewState.sessionId })
                });

                if (response.ok) {
                    const data = await response.json();
                    addMessage(data.question, 'ai');
                    
                    if (interviewState.interviewMode === 'voice') {
                        speakText(data.question);
                    }
                }
            } catch (error) {
                showError(interviewError, 'Error requesting clarification');
            } finally {
                submitBtn.disabled = false;
                submitVoiceBtn.disabled = false;
                showTyping(false);
            }
        }

        async function finishInterview() {
            if (!interviewState.sessionId) {
                showScreen('setup');
                return;
            }

            showTyping(true);
            submitBtn.disabled = true;
            submitVoiceBtn.disabled = true;

            try {
                const response = await fetch(`${API_BASE_URL}/interview/finish`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: interviewState.sessionId })
                });

                if (response.ok) {
                    const data = await response.json();
                    showFeedback(data.feedback);
                }
            } catch (error) {
                showFeedback('Interview completed. Thank you for your participation.');
            } finally {
                showTyping(false);
                submitBtn.disabled = false;
                submitVoiceBtn.disabled = false;
            }
        }

        function restartInterview() {
            interviewState.sessionId = null;
            interviewState.questionCount = 0;
            interviewState.currentTranscript = '';
            chatContainer.innerHTML = '';
            userAnswer.value = '';
            transcriptDisplay.textContent = 'Your speech will appear here...';
            feedbackContent.innerHTML = '';
            stopRecording();
            showScreen('interview');
        }

        // Keyboard shortcuts
        userAnswer.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && e.ctrlKey) {
                e.preventDefault();
                submitAnswer();
            }
        });

        // Initialize
        showScreen('setup');
        jobRoleInput.focus();
        initVisualizer();
        
        // Load voices when they become available
        speechSynthesis.onvoiceschanged = function() {
            console.log('Voices loaded:', speechSynthesis.getVoices().length);
        };

        // Handle page visibility changes (for mobile)
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && interviewState.isRecording) {
                stopRecording();
            }
        });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
</body>
</html>
